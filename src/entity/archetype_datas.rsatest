use std::fmt::Debug;
use crate::world::RemoveEntityError;
use crate::component::Component;
use crate::archetype::ArchetypeComponentType;
use crate::entity::EntityId;
use std::collections::HashMap;

pub type Iter<'s> = std::slice::Iter<'s, (EntityId, Vec<&'s dyn Component>)>;
pub type IterMut<'s> = std::slice::Iter<'s, (EntityId, Vec<&'s mut dyn Component>)>;

#[derive(Clone)]
pub struct ArchetypeStorage {
    entity_size: usize,
    component_types: Vec<ArchetypeComponentType>,
    entity_indexes: HashMap<EntityId, usize>,
    buffer: Vec<u8>,
}

impl ArchetypeStorage  {
    pub fn new(entity_size: usize, component_types: Vec<ArchetypeComponentType>,) -> ArchetypeStorage {
        ArchetypeStorage {
            entity_size,
            component_types,
            entity_indexes: HashMap::new(),
            buffer: Vec::new(),
        }
    }

    pub fn get(&self, entity_id: EntityId) -> Option<Vec<&dyn Component>> {
        match self.entity_indexes.get(&entity_id) {
            Some(index) => {
                let mut components: Vec<&dyn Component> = Vec::new();
                let entity_slices = self.buffer.chunks(&self.entity_size);
                
                match entity_slices.skip(*index).next() {
                    Some(mut entity_slice) => {
                        for component_type in self.component_types {
                            let (component_slice, rest_slice) = entity_slice.split_at(component_type.size);
                            entity_slice = rest_slice;
                            components.push((component_type.decoder)(component_slice));
                        }

                        Some(components)
                    },
                    None => None,
                }
            },
            None => None,
        }
    }

    pub fn get_mut(&mut self, entity_id: EntityId) -> Option<Vec<&mut dyn Component>> {
        match self.entity_indexes.get(&entity_id) {
            Some(index) => {
                let mut components: Vec<&mut dyn Component> = Vec::new();
                let entity_slices = self.buffer.chunks_mut(&self.entity_size);
                
                match entity_slices.skip(*index).next() {
                    Some(mut entity_slice) => {
                        for component_type in self.component_types {
                            let (component_slice, rest_slice) = entity_slice.split_at_mut(component_type.size);
                            entity_slice = rest_slice;
                            components.push((component_type.decoder_mut)(component_slice));
                        }

                        Some(components)
                    },
                    None => None,
                }
            },
            None => None,
        }
    }

    pub fn iter(&self) -> Iter<'_> {
        self.entity_indexes
            .iter()
            .filter_map(|(entity_id, _)| match self.get(*entity_id) {
                Some(components) => Some((*entity_id, components)),
                None => None,
            })
    }

    /*pub fn iter_mut(&mut self) -> IterMut<'_>
    {
        let components: Vec<(EntityId, Vec<&mut dyn Component>)> = self.entity_indexes
            .iter()
            .filter_map(|(entity_id, _)| match self.get_mut(*entity_id) {
                Some(components) => Some((*entity_id, components)),
                None => None,
            })
            .collect();

        components.iter()
    }*/

    pub fn add(&mut self, entity_id: EntityId, components: &[&mut dyn Component]) {
        self.entity_indexes.insert(entity_id, self.entity_indexes.len());
        self.buffer.append(&mut ArchetypeStorage::encode_entity(components));
    }

    pub fn remove(&mut self, entity_id: EntityId) -> Result<(), RemoveEntityError> {
        // Remove old stored id
        match self.entity_indexes.remove(&entity_id) {
            Some(index) => {
                // Remove associated binary datas
                let data_index = index * self.entity_size;
                let data_end = data_index + self.entity_size;
                self.buffer.drain(data_index .. data_end);

                // Gap all existing indexes
                self.entity_indexes = self.entity_indexes
                    .iter()
                    .map(|elem| {
                        if *elem.1 > index {
                            (*elem.0, *elem.1 - 1)
                        } else {
                            (*elem.0, *elem.1)
                        }
                    })
                    .collect();
                
                    Ok(())
            },
            None => {
                Err(RemoveEntityError::NotFound)
            },
        }
    }

    fn encode_entity(components: &[&mut dyn Component]) -> Vec<u8> {
        components
            .iter()
            .map(|component| component.encode())
            .flatten()
            .collect()
    }
}

impl Debug for ArchetypeStorage {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        let fmt_error = self.iter().find_map(|elem| {
            match elem.fmt(formatter) {
                Ok(()) => None,
                Err(err) => Some(err),
            }
        });

        match fmt_error {
            Some(err) => Err(err),
            None => Ok(()),
        }
    }
}